<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
    <title>Seed Tutorial : Standalone</title>
    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" href="../style.css" type="text/css" charset="utf-8" />
    <script type="text/javascript" src="../sh.js"></script>
    <script type="text/javascript" src="../sh_js.js"></script>
    <link type="text/css" rel="stylesheet" href="../sh.css" />
    <style type="text/css">
    div.section
    {
        font-weight: bold;
    }
    </style>

</head>
<body onload="sh_highlightDocument();">
<div id="header">Seed Tutorial : Standalone</div>
<div id="subheader">v.0.3</div>
<div class="section">Introduction</div>
<p>Seed, first and foremost, provides an easily embeddable Javascript engine to developers looking for a straightforward way to create extensible applications. It also provides bindings between <a href="http://library.gnome.org/devel/gobject/stable/">GObject</a> and the <a href="http://www.webkit.org">WebKit</a> Javascript engine, giving new developers access to the power of the GNOME stack from a familiar and simple language, and allowing rapid prototyping of applications for hardened GNOME developers.</p>
<p>This tutorial begins with a few brief examples, and then dives right in, following the development of a simple Seed program, from beginning to end. By the end of the tutorial, you'll have your very own tiny WebKit-based web browser, as well as a summary knowledge of the use of Seed to build Gtk+ applications.</p>
<div class="section">Beginning Seed</div>
<p>It makes sense to start our exploration with a program you're probably quite familiar with:</p>
<pre class="sh_javascript">
#!/usr/bin/env seed

Seed.print("Hello, world!");
</pre>
<p>If you were to make this script executable (<code>chmod +x hello.js</code>), and run it, you'd hopefully see the following, just as expected (if you don't, for some reason, make sure you have the latest version of Seed installed, then <a href="racarr@svn.gnome.org">email us</a>):</p>
<pre class="sh_javascript">
Hello, world!
</pre>
<p>In order to make the file executable, include (<code>#!/usr/bin/env seed</code>) at the top of every Seed program you write. This is known as the <em>shebang line</em>, and tells your shell where to find the <code>seed</code> interpreter; I'm only going to include it when listing a whole file, from now on.</p>
<p>Variables in Javascript are not given any <em>type</em>, and conversion between different kinds of values is automatic and painless. For example, you can:</p>
<ul>
<li>Add two strings <code>("Hello, " + "World!")</code> turns into <code>"Hello, World!"</code></li>
<li>Add a number to a string <code>("Example" + (2 * 2))</code> turns into <code>"Example4"</code></li>
</ul>
<p>There is one exception: in order to convert a string of digits into a 'number', Javascript needs to be explicitly instructed to do so: <code>parseFloat("42.5")</code>.</p>
<p>Seed also provides a very simple interface to the <a href="http://directory.fsf.org/project/readline/">GNU Readline</a> library, which allows programs to ask the user for input. This interface is in the <b>readline</b> module, which <u>must</u> be imported before it can be used. The only argument <code>readline.readline()</code> requires is the prompt for the user. Also, the current version of Seed ensures that everything typed is automatically saved in the prompt's history; if you press the up key while at a prompt, you can access and edit lines you've previously entered. Future versions of Seed will provide more control over the history and other parts of readline.</p>
<pre class="sh_javascript">
Seed.import_namespace("readline");
var my_name = readline.readline("Your name? ");
var my_age = readline.readline("Your age? ");
var old = 25;
var old_age = old + parseFloat(my_age);
Seed.print(my_name + " will be " + old_age + " in " + old + " years!");
</pre>
<p>You've probably noticed that the word '<code>var</code>' precedes the first use of every variable in Javascript. This is important, because it ensures that the memory consumed by the variable is freed to be used elsewhere at the end of the current block of code, when the variable goes <em>out of scope</em>. If, instead, you want to create a variable which is <em>global</em> (available forever, after it is created), you can omit the '<code>var</code>'. Keep in mind that making many global variables is generally considered bad practice, and can be expensive in terms of memory use.</p>
<div class="section">A Javascript Shell</div>
<p>Javascript, being a scripting language, includes a construct, <code>eval()</code> which allows you to evaluate a <em>string</em> of Javascript. This allows, for example, a user to input Javascript with <code>readline</code>, and it to be executed as if it had been part of your source file. In addition, <code>eval()</code>'s return value is the return value of the snippet of code. For example:</p>
<pre class="sh_javascript">
var output = eval("2+2");
Seed.print(output);
</pre>
<p>Will output:</p>
<pre class="sh_javascript">
4.000000
</pre>
<p>When something goes <em>wrong</em> in a piece of Javascript code, the program will exit, most likely leaving the user in a confused state. For example, if you try to access a variable that doesn't exist: <code>Seed.print(asdf);</code> Seed will exit with the message: <code>ReferenceError Can't find variable: asdf</code>. It is possible to catch this sort of error, or exception, inside of your Javascript program, ensuring that it doesn't terminate your program - or that if it does, it prints a useful error message. The <code>try/catch</code> construct provides a way to <em>try</em> to execute a segment of Javascript, and, if it fails, run a second segment, without exiting the program. The second segment could print a user-friendly error message, ignore the exception entirely, or try to work around the problem. A quick example of <code>try/catch</code>:</p>
<pre class="sh_javascript">
try
{
    Seed.print(asdf);
}
catch(e)
{
    Seed.print("Something went wrong!");
}
</pre>
<p>It's also possible to determine what, exactly, went wrong. The '<code>e</code>' in the <code>catch</code> statement (which, by the way, you <em>cannot</em> omit) is actually an object containing information about the exception! We can access some of the basic properties of this object:</p>
<pre class="sh_javascript">
try
{
    Seed.print(asdf);
}
catch(e)
{
    Seed.print("Something went wrong!");
    Seed.print(e.name);
    Seed.print(e.message);
}
</pre>
<p>This will print a message similar to what would be printed if you hadn't caught the exception, but <em>without exiting the program!</em></p>
<p>Combining <code>readline</code>, <code>eval</code>, exceptions, and <code>print</code>, we can write a simple shell, allowing interactive use of Seed. This shell is included in the Seed distribution, in <code>examples/repl.js</code>. Looking at the source, you'll note that it takes very little code to implement a shell:</p>
<div class="filename">examples/repl.js</div>
<pre class="sh_javascript">
#!/usr/bin/env seed

Seed.import_namespace("readline");

while(1)
{
    try
    {
        Seed.print(eval(readline.readline("> ")));
    }
    catch(e)
    {
        Seed.print(e.name + " " + e.message);
    }
}
</pre>
<p>You can (and <em>should!</em>) use this shell in order to experiment with and learn to use Seed.</p>
<div class="section">Getting Gtk Going</div>
<p>Thus far in this tutorial, we've been completely ignoring the most useful part of Seed: the ability to use external libraries from within Javascript. The single most useful of these libraries is Gtk, the widget and windowing toolkit used by all GNOME applications, which will provide the ability to create and manipulate graphical windows, as well as just about any sort of widget you should require.</p>
<p>In order to use Gtk (or any other external library) in a Seed program, you first have to import the functions from said library. <code>Seed.import_namespace()</code>, taking as its only argument the name of the library to import, does this for us.</p>
<p>Once the library has been imported, all of its functions are available on a global object with the same name as the library. For example, if we <code>Seed.import_namespace("Gtk")</code>, all of the imported functions are available on the Gtk object: <code><a href="http://library.gnome.org/devel/gtk/2.14/gtk-General.html#gtk-init">Gtk.init()</a></code>, etc.</p>
<p>Let's start off the development of our browser by getting Gtk working. It takes very little to get a window displayed with Seed:</p>
<pre class="sh_javascript">
#!/usr/bin/env seed

Seed.import_namespace("Gtk");
Gtk.init(null, null);

var window = new Gtk.Window();
window.show_all();

Gtk.main();
</pre>
<p>If you've ever used Gtk from C, you'll notice some similarities here. All of the Gtk functions have been mapped into Javascript in a reasonable way, but it will certainly take a bit to get used to, for example, <code>new Gtk.Window()</code> instead of <code>gtk_window_new()</code>.</p>
<p>Executing the above script should give you a window that looks entirely empty and boring, something like the following:</p>
<div style="text-align: center;"><img src="1.png" alt="Blank Gtk Window"/></div>
<div class="section">JSON Constructors</div>
<p>Notice that the title of the window is 'seed'. We'll fix that, using another Seed feature: you can use <a href="http://www.json.org/js.html">JSON notation</a> to set properties while constructing objects, like so:</p>
<pre class="sh_javascript">
var window = new Gtk.Window({title: "Browser"});
</pre>
<p>This saves a lot of typing from the alternative, conventional method:</p>
<pre class="sh_javascript">
var window = new Gtk.Window();
window.set_title("Browser");
</pre>
<p>You can set any number of properties this way, by separating them by commas (<code>{"title": "Browser", "default-height": 500}</code>, etc.). This method should work for any GObject constructor.</p>
<div class="section">Signals</div>
<p>You'll notice that our program, as it stands, fails to quit when you click the 'Close' button. You can, of course, quit it with Ctrl-C, but this is certainly unacceptable behaviour. To fix it, we'll connect a Javascript closure to the signal that gets emitted when the 'Close' button is clicked:</p>
<pre class="sh_javascript">
window.signal.hide.connect(function () { Gtk.main_quit(); });
</pre>
<p>The signal names are the same as in the <a href="http://library.gnome.org/devel/gtk/stable/">Gtk documentation</a>, except using underscores instead of dashes between words. </p>
<div class="section">GObject Subclassing</div>
<p>Inheritance is a useful feature of many object-oriented languages which provides a way to create your own classes, extending any existing class, while 'inheriting' those behaviors and properties of your parent class which you do not choose to override. Seed provides an incredibly simple interface in order to subclass GObject classes. In order to make our browser, we'll need a number of subclasses. We'll start with our toolbar; since it's a horizontal collection of elements, let's make it a subclass of Gtk.HBox:</p>
<pre class="sh_javascript">
BrowserToolbar = new GType({
    parent: Gtk.HBox.type,
    name: "BrowserToolbar",
    instance_init: function (klass)
    {

    }
});
</pre>
<div class="section">Working with Widgets</div>
<p>We'll start by making the BrowserToolbar's buttons. Gtk provides a ToolButton widget, which is generally used for making such toolbars, as well as various different stock icons (to ensure consistency within all Gtk applications). Browsing through <a href="http://library.gnome.org/devel/gtk/2.14/gtk-Stock-Items.html">the Gtk Stock Item documentation</a>, we find that we're looking for "<code>gtk-go-back</code>", "<code>gtk-go-forward</code>", and "<code>gtk-refresh</code>". A glance at the <a href="">GtkToolButton documentation</a> shows us that we can choose a stock icon by setting the <code>stock-id</code> property - we'll use JSON constructors to keep things tidy. Do note that we use underscores instead of dashes, because the property name isn't quoted (thus, a dash would indicate subtraction, which isn't what we're looking for!):</p>
<pre class="sh_javascript">
function create_ui()
{
    var main_ui = new Gtk.VBox();
    var toolbar = new Gtk.HBox();

    var back_button = new Gtk.ToolButton({stock_id: "gtk-go-back"});
    var forward_button = new Gtk.ToolButton({stock_id: "gtk-go-forward"});
    var refresh_button = new Gtk.ToolButton({stock_id: "gtk-refresh"});

    var url_entry = new Gtk.Entry();

    back_button.signal.clicked.connect(back);
    forward_button.signal.clicked.connect(forward);
    refresh_button.signal.clicked.connect(refresh);

    url_entry.signal.activate.connect(browse);

    toolbar.pack_start(back_button);
    toolbar.pack_start(forward_button);
    toolbar.pack_start(refresh_button);
    toolbar.pack_start(url_entry, true, true);

    main_ui.pack_start(toolbar);
    return main_ui;
}
</pre>
<p>There are a few things in the snippet above which you probably haven't seen before (unless you've used Gtk in another language). Firstly, the Gtk.Entry widget is a simple text entry field, like you would expect in a browser's URL bar. Secondly, you'll notice the use of the Gtk.HBox widget, and its <code>pack_start()</code> function. These serve as the foundation of GUI layout in Gtk: a window is subdivided into boxes, which 'pack' widgets in a particular direction (HBoxes pack horizontally, VBoxes pack vertically, as expected). We use a HBox, since we want our toolbar arranged horizontally. <code>pack_start()</code> adds a widget to a Box; widgets are packed in the order they're added. There are optional arguments, which are addressed in more depth in the <a href="http://library.gnome.org/devel/gtk/2.14/GtkBox.html">GtkBox documentation</a>, which allow you to force widgets to expand into the usable space (the second and third arguments used when packing <code>url_entry</code> above serve this purpose).</p>
<p>We also need a bunch of callbacks (for all three buttons, and for when you're done entering text in the URL bar). We'll make them just print the function they're supposed to perform, for now, since we don't have a WebKit view to operate on yet.</p>
<pre class="sh_javascript">
function forward(button)
{
    Seed.print("forward");
}

function back(button)
{
    Seed.print("back");
}

function refresh(button)
{
    Seed.print("refresh");
}

function browse(button)
{
    Seed.print("browser");
}
</pre>
<p>You'll notice that <code>create_ui()</code> returns an VBox with all of the widgets in it - thinking ahead, we're packing the toolbar HBox into a VBox (eventually, we'll add the WebKit view, too!). In fact, to try and get a more visual feel of packing, let's take a look at the Box layout for our browser:</p>
<div style="text-align: center;"><img src="packing.png" alt="Packing Layout"/></div>
<p>Right now, nothing's calling <code>create_ui()</code>, so you won't see the toolbar drawn. To remedy this, before <code>window.show_all()</code>, add a line to pack the toolbar:</p>
<pre class="sh_javascript">
window.add(create_ui());
</pre>
<p>Your code should be in a runnable state now; take a minute to try it out, stand back, and admire what you've learned:</p>
<div style="text-align: center;"><img src="2.png" alt="Gtk Window with buttons and text entry field" /></div>
<p>If, for some reason, something doesn't work, compare your code to <a href="1.js">the tutorial version</a>.</p>
<div class="section">Adding WebKit</div>
<p>It's finally time to start displaying some web pages with our little browser! Let's create and pack a WebKit web view below our toolbar, first. Create the browser at the top of the <code>create_ui()</code> function (we'll also need to pass the browser as the <code>this</code> object for our button callbacks, so it needs to already be created), and pack it into the <code>main_ui</code> VBox <em>after</em> you pack the toolbar. Here's an updated version of our <code>create_ui()</code> function:</p>
<pre class="sh_javascript">
function create_ui()
{
    var main_ui = new Gtk.VBox();
    var toolbar = new Gtk.HBox();

    <span class="changed">var browser = new WebKit.WebView();</span>

    var back_button = new Gtk.ToolButton({stock_id: "gtk-go-back"});
    var forward_button = new Gtk.ToolButton({stock_id: "gtk-go-forward"});
    var refresh_button = new Gtk.ToolButton({stock_id: "gtk-refresh"});

    var url_entry = new Gtk.Entry();

    back_button.signal.clicked.connect(back<span class="changed">, browser</span>);
    forward_button.signal.clicked.connect(forward<span class="changed">, browser</span>);
    refresh_button.signal.clicked.connect(refresh<span class="changed">, browser</span>);

    url_entry.signal.activate.connect(browse<span class="changed">, browser</span>);

    toolbar.pack_start(back_button);
    toolbar.pack_start(forward_button);
    toolbar.pack_start(refresh_button);
    toolbar.pack_start(url_entry, true, true);

    main_ui.pack_start(toolbar);
    <span class="changed">main_ui.pack_start(browser, true, true);</span>
    return main_ui;
}
</pre>
<p>Also, remember that we need to import a namespace before its functions are available to us! So, go back to the top of the file and import "WebKit", just after you import "Gtk". One final thing, before you again try to run your browser: we haven't yet specified a 'recommended' size for our window - let's go ahead and do that (if we didn't do so, the WebKit view would have no space to fill!). Just after you create the Gtk.Window(), add:</p>
<pre class="sh_javascript">
window.resize(600,600);
</pre>
<p>Now, fire up your browser! Hopefully, you'll see a nice blank WebKit view, like below. If you don't, take a peek at <a href="2.js">our version</a>.</p>
<div style="text-align: center;"><img src="3.png" alt="Gtk Window with toolbar and empty browser view" /></div>
<p>That's really not a very interesting browser, at all - nothing works yet, and there's no way to navigate! Still, we're almost done.</p>
<div class="section">Finishing our Browser</div>
<p>Poking around in the <a href="http://svn.webkit.org/repository/webkit/trunk/WebKit/gtk/webkit/webkitwebview.h">WebKit documentation</a> (the WebKit team is a bit behind on documentation, so all we have to work with is header files), we find that the <code>open()</code> function on a WebView allows you to navigate to a particular page. Just after you create the WebView, have it navigate to your favorite page:</p>
<pre class="sh_javascript">
browser.open("http://www.gnome.org");
</pre>
<p>A quick note about WebKit: if you omit the protocol part of a URL (e.g., http://), WebKit won't even bother to try to figure it out - so make sure you specify it! This is also important for the browse() callback, which is called when you press enter in the URL field, which we'll implement now. To get around this shortcoming, we'll use Javascript's string search function to see if a protocol has been specified, and, if it hasn't, we'll assume it's '<code>http://</code>':</p>
<pre class="sh_javascript">
function browse(url)
{
    if(url.text.search("://") < 0)
    {
        url.text = "http://" + url.text;
    }

    this.open(url.text);
}
</pre>
<p>Almost done! Next we need to implement the button callbacks. Again browsing webkitwebview.h, we find reload(), go_forward(), and go_back() - the last functions needed to finish our browser! Remembering that the browser view is passed as '<code>this</code>' to the functions, go ahead and fill them in:</p>
<pre class="sh_javascript">
function forward(button)
{
    this.go_forward();
}

function back(button)
{
    this.go_back();
}

function refresh(button)
{
    this.reload();
}
</pre>
<p>Our final modification will listen to a WebKit signal, and adjust the URL bar when you click a link. The aforementioned webkitwebview.h header file provides us with the name of the signal (load_committed). This signal is different than those we've worked with in the past, as it provides two arguments: the WebView, and a WebFrame. The distinction is important in WebKit-land, but we'll ignore it, noting only that (from the headers, again - this time, webkitwebframe.h) there is a WebFrame get_uri() function which provides the current URL of the frame. Let's first add our signal connection code. Make sure to connect to load_committed <em>after</em> you've created both the WebView and the URL entry field, as the signal is <em>on</em> the browser view, and we want to pass the URL entry field as its <code>this</code> object:</p>
<pre class="sh_javascript">
    browser.signal.load_committed.connect(url_changed, url_entry);
</pre>
<p>Next, the callback, <code>url_changed</code>. Remember that we're given two arguments, and that <code>this</code> is the URL entry field:</p>
<pre class="sh_javascript">
function url_changed(browser, frame)
{
    this.text = frame.get_uri();
}
</pre>
<p>If all goes well, your browser should now be in a working state, looking much like the following:</p>
<div style="text-align: center;"><img src="4.png" alt="Gtk Window with toolbar and browser view at GNOME.org" /></div>
<p>You will probably notice, at some point, that opening content in a new tab or new window doesn't work in your browser. This is, in fact, due to an open WebKit bug, <a href="http://bugs.webkit.org/show_bug.cgi?id=19130">#19130</a>. Once this bug is fixed, the straightforward design of your browser will make it <em>simple</em> to add support for multiple windows.</p>
<p>The final version of the tutorial's source code is available if you're having trouble; if, however, you made easy work of the tutorial, you should consider making some improvements to your browser: change the window title when the web page title changes (look at the title_changed signal!); add tabs (GtkNotebook is probably what you're looking for); bookmarks are often useful!; perhaps a status menu? Or, go ahead and write your own application in Seed!</p>
</body>
</html>
