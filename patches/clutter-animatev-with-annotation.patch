diff --git a/clutter/clutter-animation.c b/clutter/clutter-animation.c
index e1340c3..77a12f6 100644
--- a/clutter/clutter-animation.c
+++ b/clutter/clutter-animation.c
@@ -1145,6 +1145,77 @@ clutter_animation_start (ClutterAnimation *animation)
 }
 
 static inline void
+clutter_animation_setupv (ClutterAnimation *animation,
+			  const gchar      **property_names,
+			  const GValue           *values)
+{
+  ClutterAnimationPrivate *priv = animation->priv;
+  GObjectClass *klass = G_OBJECT_GET_CLASS (priv->object);
+  int length = g_strv_length((gchar **)property_names);
+  int i;
+  
+  for (i = 0; i < length; i++)
+    {
+      GParamSpec *pspec;
+      const gchar *property = property_names[i];
+      gboolean is_fixed = FALSE;
+      const GValue *final = &values[i];
+
+      if (g_str_has_prefix (property, "fixed::"))
+        {
+          is_fixed = TRUE;
+          property += 7;
+        }
+
+      pspec = g_object_class_find_property (klass, property);
+      if (!pspec)
+        {
+          g_warning ("Cannot bind property `%s': objects of type `%s' do "
+                     "not have this property",
+                     property,
+                     g_type_name (G_OBJECT_TYPE (priv->object)));
+          break;
+        }
+
+      if (!(pspec->flags & G_PARAM_WRITABLE))
+        {
+          g_warning ("Cannot bind property `%s': the property is "
+                     "not writable",
+                     property);
+          break;
+        }
+
+      if (G_LIKELY (!is_fixed))
+        {
+          ClutterInterval *interval;
+          GValue initial = { 0, };
+
+          g_value_init (&initial, G_PARAM_SPEC_VALUE_TYPE (pspec));
+          g_object_get_property (priv->object, property, &initial);
+
+          interval =
+            clutter_interval_new_with_values (G_PARAM_SPEC_VALUE_TYPE (pspec),
+                                              &initial,
+                                              final);
+
+          if (!clutter_animation_has_property (animation, pspec->name))
+            clutter_animation_bind_property_internal (animation,
+                                                      pspec,
+                                                      interval);
+          else
+            clutter_animation_update_property_internal (animation,
+                                                        pspec,
+                                                        interval);
+
+          g_value_unset (&initial);
+        }
+      else
+        g_object_set_property (priv->object, property, final);
+
+    }
+}
+
+static inline void
 clutter_animation_setup_valist (ClutterAnimation *animation,
                                 const gchar      *first_property_name,
                                 va_list           var_args)
@@ -1308,6 +1379,62 @@ clutter_actor_animate_with_alpha (ClutterActor *actor,
   return animation;
 }
 
+
+/**
+ * clutter_actor_animate_with_alphav:
+ * @actor: a #ClutterActor
+ * @alpha: a #ClutterAlpha
+ * @property_names: A %NULL terminated array of property names.
+ * @values: A %NULL terminated array of property values.
+ *
+ * A bindings friendly version of clutter_actor_animate_with_alpha()
+ * taking arrays.
+ *
+ * Return value: a #ClutterAnimation object. The object is owned by the
+ *   #ClutterActor and should not be unreferenced with g_object_unref()
+ *
+ * Since: 1.0
+ */
+ClutterAnimation *
+clutter_actor_animate_with_alphav (ClutterActor *actor,
+				   ClutterAlpha *alpha,
+				   const gchar ** property_names,
+				   const GValue *values)
+{
+  ClutterAnimation *animation;
+  ClutterTimeline *timeline;
+
+  g_return_val_if_fail (CLUTTER_IS_ACTOR (actor), NULL);
+  g_return_val_if_fail (CLUTTER_IS_ALPHA (alpha), NULL);
+  g_return_val_if_fail (property_names != NULL, NULL);
+  g_return_val_if_fail (values != NULL, NULL);
+
+  timeline = clutter_alpha_get_timeline (alpha);
+  if (G_UNLIKELY (!timeline))
+    {
+      g_warning ("The passed ClutterAlpha does not have an "
+                 "associated ClutterTimeline.");
+      return NULL;
+    }
+
+  animation = g_object_get_qdata (G_OBJECT (actor), quark_object_animation);
+  if (G_LIKELY (!animation))
+    {
+      animation = clutter_animation_new ();
+      CLUTTER_NOTE (ANIMATION, "Created new Animation [%p]", animation);
+    }
+  else
+    CLUTTER_NOTE (ANIMATION, "Reusing Animation [%p]", animation);
+
+  clutter_animation_set_timeline (animation, timeline);
+  clutter_animation_set_alpha (animation, alpha);
+  clutter_animation_set_object (animation, G_OBJECT (actor));
+
+  clutter_animation_setupv (animation, property_names, values);
+
+  return animation;
+}
+
 /**
  * clutter_actor_animate_with_timeline:
  * @actor: a #ClutterActor
@@ -1368,6 +1495,56 @@ clutter_actor_animate_with_timeline (ClutterActor    *actor,
 }
 
 /**
+ * clutter_actor_animate_with_timelinev:
+ * @actor: a #ClutterActor
+ * @mode: an animation mode logical id
+ * @timeline: a #ClutterTimeline
+ * @property_names: A %NULL terminated array of property names.
+ * @values: A %NULL terminated array of property values.
+ *
+ * A bindings friendly version of clutter_actor_animate_with_timeline()
+ * taking arrays.
+ *
+ * Return value: a #ClutterAnimation object. The object is owned by the
+ *   #ClutterActor and should not be unreferenced with g_object_unref()
+ *
+ * Since: 1.0
+ */
+ClutterAnimation *
+clutter_actor_animate_with_timelinev (ClutterActor    *actor,
+				      gulong           mode,
+				      ClutterTimeline *timeline,
+				      const gchar   **property_names,
+				      const GValue  *values)
+				      
+{
+  ClutterAnimation *animation;
+
+  g_return_val_if_fail (CLUTTER_IS_ACTOR (actor), NULL);
+  g_return_val_if_fail (CLUTTER_IS_TIMELINE (timeline), NULL);
+  g_return_val_if_fail (property_names != NULL, NULL);
+  g_return_val_if_fail (values != NULL, NULL);
+
+  animation = g_object_get_qdata (G_OBJECT (actor), quark_object_animation);
+  if (G_LIKELY (!animation))
+    {
+      animation = clutter_animation_new ();
+      CLUTTER_NOTE (ANIMATION, "Created new Animation [%p]", animation);
+    }
+  else
+    CLUTTER_NOTE (ANIMATION, "Reusing Animation [%p]", animation);
+
+  clutter_animation_set_timeline (animation, timeline);
+  clutter_animation_set_alpha (animation, NULL);
+  clutter_animation_set_mode (animation, mode);
+  clutter_animation_set_object (animation, G_OBJECT (actor));
+
+  clutter_animation_setupv (animation, property_names, values);
+
+  return animation;
+}
+
+/**
  * clutter_actor_animate:
  * @actor: a #ClutterActor
  * @mode: an animation mode logical id
@@ -1474,3 +1651,65 @@ clutter_actor_animate (ClutterActor *actor,
 
   return animation;
 }
+
+
+/**
+ * clutter_actor_animatev:
+ * @actor: A #ClutterActor
+ * @mode: an animation mode logical id
+ * @duration: duration of the animation, in milliseconds
+ * @property_names: a %NULL terminated array of property names.
+ * @values: (array zero-terminated=1) (element-type GObject.Value): a %NULL terminated array of property values.
+ *
+ * A bindings friendly version of clutter_actor_animate() taking arrays.
+ *
+ * Return value: A #ClutterAnimation object. The object is owned by the
+ *   #ClutterActor and should not be unreferenced with g_object_unref()
+ *
+ * Since: 1.0
+ **/
+ClutterAnimation *
+clutter_actor_animatev (ClutterActor *actor,
+			gulong        mode,
+			guint         duration,
+			const gchar   **property_names,
+			const GValue  *values)
+{
+  ClutterAnimation *animation;
+
+  g_return_val_if_fail (CLUTTER_IS_ACTOR (actor), NULL);
+  g_return_val_if_fail (mode != CLUTTER_CUSTOM_MODE, NULL);
+  g_return_val_if_fail (duration > 0, NULL);
+  g_return_val_if_fail (property_names != NULL, NULL);
+  g_return_val_if_fail (values != NULL, NULL);
+
+  animation = g_object_get_qdata (G_OBJECT (actor), quark_object_animation);
+  if (G_LIKELY (!animation))
+    {
+      /* if there is no animation already attached to the actor,
+       * create one and set up the timeline and alpha using the
+       * current values for duration, mode and loop
+       */
+      animation = clutter_animation_new ();
+      clutter_animation_set_timeline (animation, NULL);
+      clutter_animation_set_alpha (animation, NULL);
+      clutter_animation_set_object (animation, G_OBJECT (actor));
+
+      CLUTTER_NOTE (ANIMATION, "Created new Animation [%p]", animation);
+    }
+  else
+    CLUTTER_NOTE (ANIMATION, "Reusing Animation [%p]", animation);
+
+  /* force the update of duration and mode using the new
+   * values coming from the parameters of this function
+   */
+  clutter_animation_set_duration (animation, duration);
+  clutter_animation_set_mode (animation, mode);
+
+
+  clutter_animation_setupv (animation, property_names, values);
+
+
+  return animation;
+}
+			
diff --git a/clutter/clutter-animation.h b/clutter/clutter-animation.h
index 1b7e426..5489022 100644
--- a/clutter/clutter-animation.h
+++ b/clutter/clutter-animation.h
@@ -134,16 +134,36 @@ ClutterAnimation *   clutter_actor_animate               (ClutterActor         *
                                                           guint                 duration,
                                                           const gchar          *first_property_name,
                                                           ...) G_GNUC_NULL_TERMINATED;
+
+ClutterAnimation *   clutter_actor_animatev             (ClutterActor          *actor,
+																												 gulong                 mode,
+																												 guint                  duration,
+																												 const gchar           **property_names,
+																												 const GValue          *values);
+							 
+
 ClutterAnimation *   clutter_actor_animate_with_timeline (ClutterActor         *actor,
                                                           gulong                mode,
                                                           ClutterTimeline      *timeline,
                                                           const gchar          *first_property_name,
                                                           ...) G_GNUC_NULL_TERMINATED;
+
+ClutterAnimation *    clutter_actor_animate_with_timelinev (ClutterActor    *actor,
+																														gulong          mode,
+																														ClutterTimeline *timeline,
+																														const gchar     **property_names,
+																														const GValue    *values);
+
 ClutterAnimation *   clutter_actor_animate_with_alpha    (ClutterActor         *actor,
                                                           ClutterAlpha         *alpha,
                                                           const gchar          *first_property_name,
                                                           ...) G_GNUC_NULL_TERMINATED;
 
+ClutterAnimation *   clutter_actor_animate_with_alphav   (ClutterActor         *actor,
+							  ClutterAlpha         *alpha,
+																													const gchar          **property_names,
+																													const GValue         *values);
+
 G_END_DECLS
 
 #endif /* __CLUTTER_ANIMATION_H__ */
diff --git a/doc/reference/clutter/clutter-sections.txt b/doc/reference/clutter/clutter-sections.txt
index 8415e8d..5d52ff7 100644
--- a/doc/reference/clutter/clutter-sections.txt
+++ b/doc/reference/clutter/clutter-sections.txt
@@ -1478,8 +1478,11 @@ clutter_animation_get_interval
 
 <SUBSECTION>
 clutter_actor_animate
+clutter_actor_animatev
 clutter_actor_animate_with_timeline
+clutter_actor_animate_with_timelinev
 clutter_actor_animate_with_alpha
+clutter_actor_animate_with_alphav
 
 <SUBSECTION Standard>
 CLUTTER_TYPE_ANIMATION
